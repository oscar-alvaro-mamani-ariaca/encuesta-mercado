{"ast":null,"code":"import{useConstant}from'../../utils/use-constant.mjs';/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */class DragControls{constructor(){this.componentControls=new Set();}/**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */subscribe(controls){this.componentControls.add(controls);return()=>this.componentControls.delete(controls);}/**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */start(event,options){this.componentControls.forEach(controls=>{controls.start(event.nativeEvent||event,options);});}/**\n     * Cancels a drag gesture.\n     *\n     * ```jsx\n     * dragControls.cancel()\n     * ```\n     *\n     * @public\n     */cancel(){this.componentControls.forEach(controls=>{controls.cancel();});}/**\n     * Stops a drag gesture.\n     *\n     * ```jsx\n     * dragControls.stop()\n     * ```\n     *\n     * @public\n     */stop(){this.componentControls.forEach(controls=>{controls.stop();});}}const createDragControls=()=>new DragControls();/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */function useDragControls(){return useConstant(createDragControls);}export{DragControls,useDragControls};","map":{"version":3,"names":["useConstant","DragControls","constructor","componentControls","Set","subscribe","controls","add","delete","start","event","options","forEach","nativeEvent","cancel","stop","createDragControls","useDragControls"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/gestures/drag/use-drag-controls.mjs"],"sourcesContent":["import { useConstant } from '../../utils/use-constant.mjs';\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nclass DragControls {\n    constructor() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    subscribe(controls) {\n        this.componentControls.add(controls);\n        return () => this.componentControls.delete(controls);\n    }\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */\n    start(event, options) {\n        this.componentControls.forEach((controls) => {\n            controls.start(event.nativeEvent || event, options);\n        });\n    }\n    /**\n     * Cancels a drag gesture.\n     *\n     * ```jsx\n     * dragControls.cancel()\n     * ```\n     *\n     * @public\n     */\n    cancel() {\n        this.componentControls.forEach((controls) => {\n            controls.cancel();\n        });\n    }\n    /**\n     * Stops a drag gesture.\n     *\n     * ```jsx\n     * dragControls.stop()\n     * ```\n     *\n     * @public\n     */\n    stop() {\n        this.componentControls.forEach((controls) => {\n            controls.stop();\n        });\n    }\n}\nconst createDragControls = () => new DragControls();\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\nexport { DragControls, useDragControls };\n"],"mappings":"AAAA,OAASA,WAAW,KAAQ,8BAA8B,CAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,KAAM,CAAAC,YAAa,CACfC,WAAWA,CAAA,CAAG,CACV,IAAI,CAACC,iBAAiB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CACtC,CACA;AACJ;AACA;AACA;AACA,OACIC,SAASA,CAACC,QAAQ,CAAE,CAChB,IAAI,CAACH,iBAAiB,CAACI,GAAG,CAACD,QAAQ,CAAC,CACpC,MAAO,IAAM,IAAI,CAACH,iBAAiB,CAACK,MAAM,CAACF,QAAQ,CAAC,CACxD,CACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACIG,KAAKA,CAACC,KAAK,CAAEC,OAAO,CAAE,CAClB,IAAI,CAACR,iBAAiB,CAACS,OAAO,CAAEN,QAAQ,EAAK,CACzCA,QAAQ,CAACG,KAAK,CAACC,KAAK,CAACG,WAAW,EAAIH,KAAK,CAAEC,OAAO,CAAC,CACvD,CAAC,CAAC,CACN,CACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACIG,MAAMA,CAAA,CAAG,CACL,IAAI,CAACX,iBAAiB,CAACS,OAAO,CAAEN,QAAQ,EAAK,CACzCA,QAAQ,CAACQ,MAAM,CAAC,CAAC,CACrB,CAAC,CAAC,CACN,CACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACIC,IAAIA,CAAA,CAAG,CACH,IAAI,CAACZ,iBAAiB,CAACS,OAAO,CAAEN,QAAQ,EAAK,CACzCA,QAAQ,CAACS,IAAI,CAAC,CAAC,CACnB,CAAC,CAAC,CACN,CACJ,CACA,KAAM,CAAAC,kBAAkB,CAAGA,CAAA,GAAM,GAAI,CAAAf,YAAY,CAAC,CAAC,CACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAgB,eAAeA,CAAA,CAAG,CACvB,MAAO,CAAAjB,WAAW,CAACgB,kBAAkB,CAAC,CAC1C,CAEA,OAASf,YAAY,CAAEgB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}