{"ast":null,"code":"import{useContext}from'react';import{isAnimationControls}from'../../animation/utils/is-animation-controls.mjs';import{MotionContext}from'../../context/MotionContext/index.mjs';import{PresenceContext}from'../../context/PresenceContext.mjs';import{isControllingVariants,isVariantNode}from'../../render/utils/is-controlling-variants.mjs';import{resolveVariantFromProps}from'../../render/utils/resolve-variants.mjs';import{useConstant}from'../../utils/use-constant.mjs';import{resolveMotionValue}from'../../value/utils/resolve-motion-value.mjs';function makeState(_ref,props,context,presenceContext){let{scrapeMotionValuesFromProps,createRenderState}=_ref;const state={latestValues:makeLatestValues(props,context,presenceContext,scrapeMotionValuesFromProps),renderState:createRenderState()};return state;}function makeLatestValues(props,context,presenceContext,scrapeMotionValues){const values={};const motionValues=scrapeMotionValues(props,{});for(const key in motionValues){values[key]=resolveMotionValue(motionValues[key]);}let{initial,animate}=props;const isControllingVariants$1=isControllingVariants(props);const isVariantNode$1=isVariantNode(props);if(context&&isVariantNode$1&&!isControllingVariants$1&&props.inherit!==false){if(initial===undefined)initial=context.initial;if(animate===undefined)animate=context.animate;}let isInitialAnimationBlocked=presenceContext?presenceContext.initial===false:false;isInitialAnimationBlocked=isInitialAnimationBlocked||initial===false;const variantToSet=isInitialAnimationBlocked?animate:initial;if(variantToSet&&typeof variantToSet!==\"boolean\"&&!isAnimationControls(variantToSet)){const list=Array.isArray(variantToSet)?variantToSet:[variantToSet];for(let i=0;i<list.length;i++){const resolved=resolveVariantFromProps(props,list[i]);if(resolved){const{transitionEnd,transition,...target}=resolved;for(const key in target){let valueTarget=target[key];if(Array.isArray(valueTarget)){/**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */const index=isInitialAnimationBlocked?valueTarget.length-1:0;valueTarget=valueTarget[index];}if(valueTarget!==null){values[key]=valueTarget;}}for(const key in transitionEnd){values[key]=transitionEnd[key];}}}}return values;}const makeUseVisualState=config=>(props,isStatic)=>{const context=useContext(MotionContext);const presenceContext=useContext(PresenceContext);const make=()=>makeState(config,props,context,presenceContext);return isStatic?make():useConstant(make);};export{makeUseVisualState};","map":{"version":3,"names":["useContext","isAnimationControls","MotionContext","PresenceContext","isControllingVariants","isVariantNode","resolveVariantFromProps","useConstant","resolveMotionValue","makeState","_ref","props","context","presenceContext","scrapeMotionValuesFromProps","createRenderState","state","latestValues","makeLatestValues","renderState","scrapeMotionValues","values","motionValues","key","initial","animate","isControllingVariants$1","isVariantNode$1","inherit","undefined","isInitialAnimationBlocked","variantToSet","list","Array","isArray","i","length","resolved","transitionEnd","transition","target","valueTarget","index","makeUseVisualState","config","isStatic","make"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs"],"sourcesContent":["import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    return state;\n}\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\n\nexport { makeUseVisualState };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}