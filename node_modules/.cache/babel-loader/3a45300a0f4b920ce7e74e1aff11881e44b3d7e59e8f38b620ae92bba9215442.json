{"ast":null,"code":"import{isMotionValue,defaultOffset,isGenerator,createGeneratorEasing,fillOffset}from'motion-dom';import{progress,secondsToMilliseconds,invariant,getEasingForSegment}from'motion-utils';import{resolveSubjects}from'../animate/resolve-subjects.mjs';import{calculateRepeatDuration}from'./utils/calc-repeat-duration.mjs';import{calcNextTime}from'./utils/calc-time.mjs';import{addKeyframes}from'./utils/edit.mjs';import{normalizeTimes}from'./utils/normalize-times.mjs';import{compareByTime}from'./utils/sort.mjs';const defaultSegmentEasing=\"easeInOut\";const MAX_REPEAT=20;function createAnimationsFromSequence(sequence){let{defaultTransition={},...sequenceTransition}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let scope=arguments.length>2?arguments[2]:undefined;let generators=arguments.length>3?arguments[3]:undefined;const defaultDuration=defaultTransition.duration||0.3;const animationDefinitions=new Map();const sequences=new Map();const elementCache={};const timeLabels=new Map();let prevTime=0;let currentTime=0;let totalDuration=0;/**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */for(let i=0;i<sequence.length;i++){const segment=sequence[i];/**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */if(typeof segment===\"string\"){timeLabels.set(segment,currentTime);continue;}else if(!Array.isArray(segment)){timeLabels.set(segment.name,calcNextTime(currentTime,segment.at,prevTime,timeLabels));continue;}let[subject,keyframes,transition={}]=segment;/**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */if(transition.at!==undefined){currentTime=calcNextTime(currentTime,transition.at,prevTime,timeLabels);}/**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */let maxDuration=0;const resolveValueSequence=function(valueKeyframes,valueTransition,valueSequence){var _duration;let elementIndex=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;let numSubjects=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;const valueKeyframesAsList=keyframesAsList(valueKeyframes);const{delay=0,times=defaultOffset(valueKeyframesAsList),type=\"keyframes\",repeat,repeatType,repeatDelay=0,...remainingTransition}=valueTransition;let{ease=defaultTransition.ease||\"easeOut\",duration}=valueTransition;/**\n             * Resolve stagger() if defined.\n             */const calculatedDelay=typeof delay===\"function\"?delay(elementIndex,numSubjects):delay;/**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */const numKeyframes=valueKeyframesAsList.length;const createGenerator=isGenerator(type)?type:generators===null||generators===void 0?void 0:generators[type||\"keyframes\"];if(numKeyframes<=2&&createGenerator){/**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */let absoluteDelta=100;if(numKeyframes===2&&isNumberKeyframesArray(valueKeyframesAsList)){const delta=valueKeyframesAsList[1]-valueKeyframesAsList[0];absoluteDelta=Math.abs(delta);}const springTransition={...remainingTransition};if(duration!==undefined){springTransition.duration=secondsToMilliseconds(duration);}const springEasing=createGeneratorEasing(springTransition,absoluteDelta,createGenerator);ease=springEasing.ease;duration=springEasing.duration;}(_duration=duration)!==null&&_duration!==void 0?_duration:duration=defaultDuration;const startTime=currentTime+calculatedDelay;/**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */if(times.length===1&&times[0]===0){times[1]=1;}/**\n             * Fill out if offset if fewer offsets than keyframes\n             */const remainder=times.length-valueKeyframesAsList.length;remainder>0&&fillOffset(times,remainder);/**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */valueKeyframesAsList.length===1&&valueKeyframesAsList.unshift(null);/**\n             * Handle repeat options\n             */if(repeat){invariant(repeat<MAX_REPEAT,\"Repeat count too high, must be less than 20\",\"repeat-count-high\");duration=calculateRepeatDuration(duration,repeat);const originalKeyframes=[...valueKeyframesAsList];const originalTimes=[...times];ease=Array.isArray(ease)?[...ease]:[ease];const originalEase=[...ease];for(let repeatIndex=0;repeatIndex<repeat;repeatIndex++){valueKeyframesAsList.push(...originalKeyframes);for(let keyframeIndex=0;keyframeIndex<originalKeyframes.length;keyframeIndex++){times.push(originalTimes[keyframeIndex]+(repeatIndex+1));ease.push(keyframeIndex===0?\"linear\":getEasingForSegment(originalEase,keyframeIndex-1));}}normalizeTimes(times,repeat);}const targetTime=startTime+duration;/**\n             * Add keyframes, mapping offsets to absolute time.\n             */addKeyframes(valueSequence,valueKeyframesAsList,ease,times,startTime,targetTime);maxDuration=Math.max(calculatedDelay+duration,maxDuration);totalDuration=Math.max(targetTime,totalDuration);};if(isMotionValue(subject)){const subjectSequence=getSubjectSequence(subject,sequences);resolveValueSequence(keyframes,transition,getValueSequence(\"default\",subjectSequence));}else{const subjects=resolveSubjects(subject,keyframes,scope,elementCache);const numSubjects=subjects.length;/**\n             * For every element in this segment, process the defined values.\n             */for(let subjectIndex=0;subjectIndex<numSubjects;subjectIndex++){/**\n                 * Cast necessary, but we know these are of this type\n                 */keyframes=keyframes;transition=transition;const thisSubject=subjects[subjectIndex];const subjectSequence=getSubjectSequence(thisSubject,sequences);for(const key in keyframes){resolveValueSequence(keyframes[key],getValueTransition(transition,key),getValueSequence(key,subjectSequence),subjectIndex,numSubjects);}}}prevTime=currentTime;currentTime+=maxDuration;}/**\n     * For every element and value combination create a new animation.\n     */sequences.forEach((valueSequences,element)=>{for(const key in valueSequences){const valueSequence=valueSequences[key];/**\n             * Arrange all the keyframes in ascending time order.\n             */valueSequence.sort(compareByTime);const keyframes=[];const valueOffset=[];const valueEasing=[];/**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */for(let i=0;i<valueSequence.length;i++){const{at,value,easing}=valueSequence[i];keyframes.push(value);valueOffset.push(progress(0,totalDuration,at));valueEasing.push(easing||\"easeOut\");}/**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */if(valueOffset[0]!==0){valueOffset.unshift(0);keyframes.unshift(keyframes[0]);valueEasing.unshift(defaultSegmentEasing);}/**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */if(valueOffset[valueOffset.length-1]!==1){valueOffset.push(1);keyframes.push(null);}if(!animationDefinitions.has(element)){animationDefinitions.set(element,{keyframes:{},transition:{}});}const definition=animationDefinitions.get(element);definition.keyframes[key]=keyframes;definition.transition[key]={...defaultTransition,duration:totalDuration,ease:valueEasing,times:valueOffset,...sequenceTransition};}});return animationDefinitions;}function getSubjectSequence(subject,sequences){!sequences.has(subject)&&sequences.set(subject,{});return sequences.get(subject);}function getValueSequence(name,sequences){if(!sequences[name])sequences[name]=[];return sequences[name];}function keyframesAsList(keyframes){return Array.isArray(keyframes)?keyframes:[keyframes];}function getValueTransition(transition,key){return transition&&transition[key]?{...transition,...transition[key]}:{...transition};}const isNumber=keyframe=>typeof keyframe===\"number\";const isNumberKeyframesArray=keyframes=>keyframes.every(isNumber);export{createAnimationsFromSequence,getValueTransition};","map":{"version":3,"names":["isMotionValue","defaultOffset","isGenerator","createGeneratorEasing","fillOffset","progress","secondsToMilliseconds","invariant","getEasingForSegment","resolveSubjects","calculateRepeatDuration","calcNextTime","addKeyframes","normalizeTimes","compareByTime","defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","arguments","length","undefined","scope","generators","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","set","Array","isArray","name","at","subject","keyframes","transition","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","_duration","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","type","repeat","repeatType","repeatDelay","remainingTransition","ease","calculatedDelay","numKeyframes","createGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","springEasing","startTime","remainder","unshift","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","targetTime","max","subjectSequence","getSubjectSequence","getValueSequence","subjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","valueOffset","valueEasing","value","easing","has","definition","get","isNumber","keyframe","every"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { isMotionValue, defaultOffset, isGenerator, createGeneratorEasing, fillOffset } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant, getEasingForSegment } from 'motion-utils';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numSubjects)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration ?? (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\", \"repeat-count-high\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [...valueKeyframesAsList];\n                const originalTimes = [...times];\n                ease = Array.isArray(ease) ? [...ease] : [ease];\n                const originalEase = [...ease];\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0\n                            ? \"linear\"\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}