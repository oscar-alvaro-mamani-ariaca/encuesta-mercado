{"ast":null,"code":"import{MotionGlobalConfig,noop}from'motion-utils';import{time}from'../frameloop/sync-time.mjs';import{JSAnimation}from'./JSAnimation.mjs';import{getFinalKeyframe}from'./keyframes/get-final.mjs';import{KeyframeResolver,flushKeyframeResolvers}from'./keyframes/KeyframesResolver.mjs';import{NativeAnimationExtended}from'./NativeAnimationExtended.mjs';import{canAnimate}from'./utils/can-animate.mjs';import{makeAnimationInstant}from'./utils/make-animation-instant.mjs';import{WithPromise}from'./utils/WithPromise.mjs';import{supportsBrowserAnimation}from'./waapi/supports/waapi.mjs';/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */const MAX_RESOLVE_DELAY=40;class AsyncMotionValueAnimation extends WithPromise{constructor(_ref){var _this$keyframeResolve2;let{autoplay=true,delay=0,type=\"keyframes\",repeat=0,repeatDelay=0,repeatType=\"loop\",keyframes,name,motionValue,element,...options}=_ref;super();/**\n         * Bound to support return animation.stop pattern\n         */this.stop=()=>{var _this$keyframeResolve;if(this._animation){var _this$stopTimeline;this._animation.stop();(_this$stopTimeline=this.stopTimeline)===null||_this$stopTimeline===void 0?void 0:_this$stopTimeline.call(this);}(_this$keyframeResolve=this.keyframeResolver)===null||_this$keyframeResolve===void 0?void 0:_this$keyframeResolve.cancel();};this.createdAt=time.now();const optionsWithDefaults={autoplay,delay,type,repeat,repeatDelay,repeatType,name,motionValue,element,...options};const KeyframeResolver$1=(element===null||element===void 0?void 0:element.KeyframeResolver)||KeyframeResolver;this.keyframeResolver=new KeyframeResolver$1(keyframes,(resolvedKeyframes,finalKeyframe,forced)=>this.onKeyframesResolved(resolvedKeyframes,finalKeyframe,optionsWithDefaults,!forced),name,motionValue,element);(_this$keyframeResolve2=this.keyframeResolver)===null||_this$keyframeResolve2===void 0?void 0:_this$keyframeResolve2.scheduleResolve();}onKeyframesResolved(keyframes,finalKeyframe,options,sync){this.keyframeResolver=undefined;const{name,type,velocity,delay,isHandoff,onUpdate}=options;this.resolvedAt=time.now();/**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */if(!canAnimate(keyframes,name,type,velocity)){if(MotionGlobalConfig.instantAnimations||!delay){onUpdate===null||onUpdate===void 0?void 0:onUpdate(getFinalKeyframe(keyframes,options,finalKeyframe));}keyframes[0]=keyframes[keyframes.length-1];makeAnimationInstant(options);options.repeat=0;}/**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */const startTime=sync?!this.resolvedAt?this.createdAt:this.resolvedAt-this.createdAt>MAX_RESOLVE_DELAY?this.resolvedAt:this.createdAt:undefined;const resolvedOptions={startTime,finalKeyframe,...options,keyframes};/**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */const animation=!isHandoff&&supportsBrowserAnimation(resolvedOptions)?new NativeAnimationExtended({...resolvedOptions,element:resolvedOptions.motionValue.owner.current}):new JSAnimation(resolvedOptions);animation.finished.then(()=>this.notifyFinished()).catch(noop);if(this.pendingTimeline){this.stopTimeline=animation.attachTimeline(this.pendingTimeline);this.pendingTimeline=undefined;}this._animation=animation;}get finished(){if(!this._animation){return this._finished;}else{return this.animation.finished;}}then(onResolve,_onReject){return this.finished.finally(onResolve).then(()=>{});}get animation(){if(!this._animation){var _this$keyframeResolve3;(_this$keyframeResolve3=this.keyframeResolver)===null||_this$keyframeResolve3===void 0?void 0:_this$keyframeResolve3.resume();flushKeyframeResolvers();}return this._animation;}get duration(){return this.animation.duration;}get time(){return this.animation.time;}set time(newTime){this.animation.time=newTime;}get speed(){return this.animation.speed;}get state(){return this.animation.state;}set speed(newSpeed){this.animation.speed=newSpeed;}get startTime(){return this.animation.startTime;}attachTimeline(timeline){if(this._animation){this.stopTimeline=this.animation.attachTimeline(timeline);}else{this.pendingTimeline=timeline;}return()=>this.stop();}play(){this.animation.play();}pause(){this.animation.pause();}complete(){this.animation.complete();}cancel(){var _this$keyframeResolve4;if(this._animation){this.animation.cancel();}(_this$keyframeResolve4=this.keyframeResolver)===null||_this$keyframeResolve4===void 0?void 0:_this$keyframeResolve4.cancel();}}export{AsyncMotionValueAnimation};","map":{"version":3,"names":["MotionGlobalConfig","noop","time","JSAnimation","getFinalKeyframe","KeyframeResolver","flushKeyframeResolvers","NativeAnimationExtended","canAnimate","makeAnimationInstant","WithPromise","supportsBrowserAnimation","MAX_RESOLVE_DELAY","AsyncMotionValueAnimation","constructor","_ref","_this$keyframeResolve2","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","stop","_this$keyframeResolve","_animation","_this$stopTimeline","stopTimeline","call","keyframeResolver","cancel","createdAt","now","optionsWithDefaults","KeyframeResolver$1","resolvedKeyframes","finalKeyframe","forced","onKeyframesResolved","scheduleResolve","sync","undefined","velocity","isHandoff","onUpdate","resolvedAt","instantAnimations","length","startTime","resolvedOptions","animation","owner","current","finished","then","notifyFinished","catch","pendingTimeline","attachTimeline","_finished","onResolve","_onReject","finally","_this$keyframeResolve3","resume","duration","newTime","speed","state","newSpeed","timeline","play","pause","complete","_this$keyframeResolve4"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs"],"sourcesContent":["import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { makeAnimationInstant } from './utils/make-animation-instant.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", keyframes, name, motionValue, element, ...options }) {\n        super();\n        /**\n         * Bound to support return animation.stop pattern\n         */\n        this.stop = () => {\n            if (this._animation) {\n                this._animation.stop();\n                this.stopTimeline?.();\n            }\n            this.keyframeResolver?.cancel();\n        };\n        this.createdAt = time.now();\n        const optionsWithDefaults = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        };\n        const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n        this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n        this.keyframeResolver?.scheduleResolve();\n    }\n    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n        this.keyframeResolver = undefined;\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options;\n        this.resolvedAt = time.now();\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n            }\n            keyframes[0] = keyframes[keyframes.length - 1];\n            makeAnimationInstant(options);\n            options.repeat = 0;\n        }\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                    ? this.resolvedAt\n                    : this.createdAt\n            : undefined;\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        };\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n            ? new NativeAnimationExtended({\n                ...resolvedOptions,\n                element: resolvedOptions.motionValue.owner.current,\n            })\n            : new JSAnimation(resolvedOptions);\n        animation.finished.then(() => this.notifyFinished()).catch(noop);\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        this._animation = animation;\n    }\n    get finished() {\n        if (!this._animation) {\n            return this._finished;\n        }\n        else {\n            return this.animation.finished;\n        }\n    }\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n    get animation() {\n        if (!this._animation) {\n            this.keyframeResolver?.resume();\n            flushKeyframeResolvers();\n        }\n        return this._animation;\n    }\n    get duration() {\n        return this.animation.duration;\n    }\n    get time() {\n        return this.animation.time;\n    }\n    set time(newTime) {\n        this.animation.time = newTime;\n    }\n    get speed() {\n        return this.animation.speed;\n    }\n    get state() {\n        return this.animation.state;\n    }\n    set speed(newSpeed) {\n        this.animation.speed = newSpeed;\n    }\n    get startTime() {\n        return this.animation.startTime;\n    }\n    attachTimeline(timeline) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline);\n        }\n        else {\n            this.pendingTimeline = timeline;\n        }\n        return () => this.stop();\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.complete();\n    }\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel();\n        }\n        this.keyframeResolver?.cancel();\n    }\n}\n\nexport { AsyncMotionValueAnimation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}