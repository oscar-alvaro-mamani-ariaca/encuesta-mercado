{"ast":null,"code":"import{animateVisualElement}from'../../animation/interfaces/visual-element.mjs';import{calcChildStagger}from'../../animation/utils/calc-child-stagger.mjs';import{isAnimationControls}from'../../animation/utils/is-animation-controls.mjs';import{isKeyframesTarget}from'../../animation/utils/is-keyframes-target.mjs';import{shallowCompare}from'../../utils/shallow-compare.mjs';import{getVariantContext}from'./get-variant-context.mjs';import{isVariantLabel}from'./is-variant-label.mjs';import{resolveVariant}from'./resolve-dynamic-variants.mjs';import{variantPriorityOrder}from'./variant-props.mjs';const reversePriorityOrder=[...variantPriorityOrder].reverse();const numAnimationTypes=variantPriorityOrder.length;function animateList(visualElement){return animations=>Promise.all(animations.map(_ref=>{let{animation,options}=_ref;return animateVisualElement(visualElement,animation,options);}));}function createAnimationState(visualElement){let animate=animateList(visualElement);let state=createState();let isInitialRender=true;/**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */const buildResolvedTypeValues=type=>(acc,definition)=>{var _visualElement$presen;const resolved=resolveVariant(visualElement,definition,type===\"exit\"?(_visualElement$presen=visualElement.presenceContext)===null||_visualElement$presen===void 0?void 0:_visualElement$presen.custom:undefined);if(resolved){const{transition,transitionEnd,...target}=resolved;acc={...acc,...target,...transitionEnd};}return acc;};/**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */function setAnimateFunction(makeAnimator){animate=makeAnimator(visualElement);}/**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */function animateChanges(changedActiveType){const{props}=visualElement;const context=getVariantContext(visualElement.parent)||{};/**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */const animations=[];/**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */const removedKeys=new Set();/**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */let encounteredKeys={};/**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */let removedVariantIndex=Infinity;/**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */for(let i=0;i<numAnimationTypes;i++){const type=reversePriorityOrder[i];const typeState=state[type];const prop=props[type]!==undefined?props[type]:context[type];const propIsVariant=isVariantLabel(prop);/**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */const activeDelta=type===changedActiveType?typeState.isActive:null;if(activeDelta===false)removedVariantIndex=i;/**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */let isInherited=prop===context[type]&&prop!==props[type]&&propIsVariant;if(isInherited&&isInitialRender&&visualElement.manuallyAnimateOnMount){isInherited=false;}/**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */typeState.protectedKeys={...encounteredKeys};// Check if we can skip analysing this prop early\nif(// If it isn't active and hasn't *just* been set as inactive\n!typeState.isActive&&activeDelta===null||// If we didn't and don't have any defined prop for this animation type\n!prop&&!typeState.prevProp||// Or if the prop doesn't define an animation\nisAnimationControls(prop)||typeof prop===\"boolean\"){continue;}/**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */const variantDidChange=checkVariantsDidChange(typeState.prevProp,prop);let shouldAnimateType=variantDidChange||// If we're making this variant active, we want to always make it active\ntype===changedActiveType&&typeState.isActive&&!isInherited&&propIsVariant||// If we removed a higher-priority variant (i is in reverse order)\ni>removedVariantIndex&&propIsVariant;let handledRemovedValues=false;/**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */const definitionList=Array.isArray(prop)?prop:[prop];/**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */let resolvedValues=definitionList.reduce(buildResolvedTypeValues(type),{});if(activeDelta===false)resolvedValues={};/**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */const{prevResolvedValues={}}=typeState;const allKeys={...prevResolvedValues,...resolvedValues};const markToAnimate=key=>{shouldAnimateType=true;if(removedKeys.has(key)){handledRemovedValues=true;removedKeys.delete(key);}typeState.needsAnimating[key]=true;const motionValue=visualElement.getValue(key);if(motionValue)motionValue.liveStyle=false;};for(const key in allKeys){const next=resolvedValues[key];const prev=prevResolvedValues[key];// If we've already handled this we can just skip ahead\nif(encounteredKeys.hasOwnProperty(key))continue;/**\n                 * If the value has changed, we probably want to animate it.\n                 */let valueHasChanged=false;if(isKeyframesTarget(next)&&isKeyframesTarget(prev)){valueHasChanged=!shallowCompare(next,prev);}else{valueHasChanged=next!==prev;}if(valueHasChanged){if(next!==undefined&&next!==null){// If next is defined and doesn't equal prev, it needs animating\nmarkToAnimate(key);}else{// If it's undefined, it's been removed.\nremovedKeys.add(key);}}else if(next!==undefined&&removedKeys.has(key)){/**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */markToAnimate(key);}else{/**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */typeState.protectedKeys[key]=true;}}/**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */typeState.prevProp=prop;typeState.prevResolvedValues=resolvedValues;if(typeState.isActive){encounteredKeys={...encounteredKeys,...resolvedValues};}if(isInitialRender&&visualElement.blockInitialAnimation){shouldAnimateType=false;}/**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */const willAnimateViaParent=isInherited&&variantDidChange;const needsAnimating=!willAnimateViaParent||handledRemovedValues;if(shouldAnimateType&&needsAnimating){animations.push(...definitionList.map(animation=>{const options={type};/**\n                     * If we're performing the initial animation, but we're not\n                     * rendering at the same time as the variant-controlling parent,\n                     * we want to use the parent's transition to calculate the stagger.\n                     */if(typeof animation===\"string\"&&isInitialRender&&!willAnimateViaParent&&visualElement.manuallyAnimateOnMount&&visualElement.parent){const{parent}=visualElement;const parentVariant=resolveVariant(parent,animation);if(parent.enteringChildren&&parentVariant){const{delayChildren}=parentVariant.transition||{};options.delay=calcChildStagger(parent.enteringChildren,visualElement,delayChildren);}}return{animation:animation,options};}));}}/**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */if(removedKeys.size){const fallbackAnimation={};/**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */if(typeof props.initial!==\"boolean\"){const initialTransition=resolveVariant(visualElement,Array.isArray(props.initial)?props.initial[0]:props.initial);if(initialTransition&&initialTransition.transition){fallbackAnimation.transition=initialTransition.transition;}}removedKeys.forEach(key=>{const fallbackTarget=visualElement.getBaseTarget(key);const motionValue=visualElement.getValue(key);if(motionValue)motionValue.liveStyle=true;// @ts-expect-error - @mattgperry to figure if we should do something here\nfallbackAnimation[key]=fallbackTarget!==null&&fallbackTarget!==void 0?fallbackTarget:null;});animations.push({animation:fallbackAnimation});}let shouldAnimate=Boolean(animations.length);if(isInitialRender&&(props.initial===false||props.initial===props.animate)&&!visualElement.manuallyAnimateOnMount){shouldAnimate=false;}isInitialRender=false;return shouldAnimate?animate(animations):Promise.resolve();}/**\n     * Change whether a certain animation type is active.\n     */function setActive(type,isActive){var _visualElement$varian;// If the active state hasn't changed, we can safely do nothing here\nif(state[type].isActive===isActive)return Promise.resolve();// Propagate active change to children\n(_visualElement$varian=visualElement.variantChildren)===null||_visualElement$varian===void 0?void 0:_visualElement$varian.forEach(child=>{var _child$animationState;return(_child$animationState=child.animationState)===null||_child$animationState===void 0?void 0:_child$animationState.setActive(type,isActive);});state[type].isActive=isActive;const animations=animateChanges(type);for(const key in state){state[key].protectedKeys={};}return animations;}return{animateChanges,setActive,setAnimateFunction,getState:()=>state,reset:()=>{state=createState();isInitialRender=true;}};}function checkVariantsDidChange(prev,next){if(typeof next===\"string\"){return next!==prev;}else if(Array.isArray(next)){return!shallowCompare(next,prev);}return false;}function createTypeState(){let isActive=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;return{isActive,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}};}function createState(){return{animate:createTypeState(true),whileInView:createTypeState(),whileHover:createTypeState(),whileTap:createTypeState(),whileDrag:createTypeState(),whileFocus:createTypeState(),exit:createTypeState()};}export{checkVariantsDidChange,createAnimationState};","map":{"version":3,"names":["animateVisualElement","calcChildStagger","isAnimationControls","isKeyframesTarget","shallowCompare","getVariantContext","isVariantLabel","resolveVariant","variantPriorityOrder","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","_ref","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","_visualElement$presen","resolved","presenceContext","custom","undefined","transition","transitionEnd","target","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","context","parent","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","has","delete","needsAnimating","motionValue","getValue","liveStyle","next","prev","hasOwnProperty","valueHasChanged","add","blockInitialAnimation","willAnimateViaParent","push","parentVariant","enteringChildren","delayChildren","delay","size","fallbackAnimation","initial","initialTransition","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","resolve","setActive","_visualElement$varian","variantChildren","child","_child$animationState","animationState","getState","reset","createTypeState","arguments","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { calcChildStagger } from '../../animation/utils/calc-child-stagger.mjs';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? visualElement.presenceContext?.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => {\n                    const options = { type };\n                    /**\n                     * If we're performing the initial animation, but we're not\n                     * rendering at the same time as the variant-controlling parent,\n                     * we want to use the parent's transition to calculate the stagger.\n                     */\n                    if (typeof animation === \"string\" &&\n                        isInitialRender &&\n                        !willAnimateViaParent &&\n                        visualElement.manuallyAnimateOnMount &&\n                        visualElement.parent) {\n                        const { parent } = visualElement;\n                        const parentVariant = resolveVariant(parent, animation);\n                        if (parent.enteringChildren && parentVariant) {\n                            const { delayChildren } = parentVariant.transition || {};\n                            options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);\n                        }\n                    }\n                    return {\n                        animation: animation,\n                        options,\n                    };\n                }));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            /**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */\n            if (typeof props.initial !== \"boolean\") {\n                const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)\n                    ? props.initial[0]\n                    : props.initial);\n                if (initialTransition && initialTransition.transition) {\n                    fallbackAnimation.transition = initialTransition.transition;\n                }\n            }\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget ?? null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}