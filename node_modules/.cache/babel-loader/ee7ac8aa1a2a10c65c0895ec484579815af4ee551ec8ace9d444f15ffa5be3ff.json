{"ast":null,"code":"function buildProjectionTransform(delta,treeScale,latestTransform){let transform=\"\";/**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */const xTranslate=delta.x.translate/treeScale.x;const yTranslate=delta.y.translate/treeScale.y;const zTranslate=(latestTransform===null||latestTransform===void 0?void 0:latestTransform.z)||0;if(xTranslate||yTranslate||zTranslate){transform=`translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;}/**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */if(treeScale.x!==1||treeScale.y!==1){transform+=`scale(${1/treeScale.x}, ${1/treeScale.y}) `;}if(latestTransform){const{transformPerspective,rotate,rotateX,rotateY,skewX,skewY}=latestTransform;if(transformPerspective)transform=`perspective(${transformPerspective}px) ${transform}`;if(rotate)transform+=`rotate(${rotate}deg) `;if(rotateX)transform+=`rotateX(${rotateX}deg) `;if(rotateY)transform+=`rotateY(${rotateY}deg) `;if(skewX)transform+=`skewX(${skewX}deg) `;if(skewY)transform+=`skewY(${skewY}deg) `;}/**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */const elementScaleX=delta.x.scale*treeScale.x;const elementScaleY=delta.y.scale*treeScale.y;if(elementScaleX!==1||elementScaleY!==1){transform+=`scale(${elementScaleX}, ${elementScaleY})`;}return transform||\"none\";}export{buildProjectionTransform};","map":{"version":3,"names":["buildProjectionTransform","delta","treeScale","latestTransform","transform","xTranslate","x","translate","yTranslate","y","zTranslate","z","transformPerspective","rotate","rotateX","rotateY","skewX","skewY","elementScaleX","scale","elementScaleY"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/projection/styles/transform.mjs"],"sourcesContent":["function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = latestTransform?.z || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n"],"mappings":"AAAA,QAAS,CAAAA,wBAAwBA,CAACC,KAAK,CAAEC,SAAS,CAAEC,eAAe,CAAE,CACjE,GAAI,CAAAC,SAAS,CAAG,EAAE,CAClB;AACJ;AACA;AACA;AACA;AACA,OACI,KAAM,CAAAC,UAAU,CAAGJ,KAAK,CAACK,CAAC,CAACC,SAAS,CAAGL,SAAS,CAACI,CAAC,CAClD,KAAM,CAAAE,UAAU,CAAGP,KAAK,CAACQ,CAAC,CAACF,SAAS,CAAGL,SAAS,CAACO,CAAC,CAClD,KAAM,CAAAC,UAAU,CAAG,CAAAP,eAAe,SAAfA,eAAe,iBAAfA,eAAe,CAAEQ,CAAC,GAAI,CAAC,CAC1C,GAAIN,UAAU,EAAIG,UAAU,EAAIE,UAAU,CAAE,CACxCN,SAAS,CAAG,eAAeC,UAAU,OAAOG,UAAU,OAAOE,UAAU,MAAM,CACjF,CACA;AACJ;AACA;AACA,OACI,GAAIR,SAAS,CAACI,CAAC,GAAK,CAAC,EAAIJ,SAAS,CAACO,CAAC,GAAK,CAAC,CAAE,CACxCL,SAAS,EAAI,SAAS,CAAC,CAAGF,SAAS,CAACI,CAAC,KAAK,CAAC,CAAGJ,SAAS,CAACO,CAAC,IAAI,CACjE,CACA,GAAIN,eAAe,CAAE,CACjB,KAAM,CAAES,oBAAoB,CAAEC,MAAM,CAAEC,OAAO,CAAEC,OAAO,CAAEC,KAAK,CAAEC,KAAM,CAAC,CAAGd,eAAe,CACxF,GAAIS,oBAAoB,CACpBR,SAAS,CAAG,eAAeQ,oBAAoB,OAAOR,SAAS,EAAE,CACrE,GAAIS,MAAM,CACNT,SAAS,EAAI,UAAUS,MAAM,OAAO,CACxC,GAAIC,OAAO,CACPV,SAAS,EAAI,WAAWU,OAAO,OAAO,CAC1C,GAAIC,OAAO,CACPX,SAAS,EAAI,WAAWW,OAAO,OAAO,CAC1C,GAAIC,KAAK,CACLZ,SAAS,EAAI,SAASY,KAAK,OAAO,CACtC,GAAIC,KAAK,CACLb,SAAS,EAAI,SAASa,KAAK,OAAO,CAC1C,CACA;AACJ;AACA;AACA,OACI,KAAM,CAAAC,aAAa,CAAGjB,KAAK,CAACK,CAAC,CAACa,KAAK,CAAGjB,SAAS,CAACI,CAAC,CACjD,KAAM,CAAAc,aAAa,CAAGnB,KAAK,CAACQ,CAAC,CAACU,KAAK,CAAGjB,SAAS,CAACO,CAAC,CACjD,GAAIS,aAAa,GAAK,CAAC,EAAIE,aAAa,GAAK,CAAC,CAAE,CAC5ChB,SAAS,EAAI,SAASc,aAAa,KAAKE,aAAa,GAAG,CAC5D,CACA,MAAO,CAAAhB,SAAS,EAAI,MAAM,CAC9B,CAEA,OAASJ,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}