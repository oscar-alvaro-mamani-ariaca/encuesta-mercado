{"ast":null,"code":"import{invariant,pipe,clamp,millisecondsToSeconds,secondsToMilliseconds}from'motion-utils';import{time}from'../frameloop/sync-time.mjs';import{activeAnimations}from'../stats/animation-count.mjs';import{mix}from'../utils/mix/index.mjs';import{frameloopDriver}from'./drivers/frame.mjs';import{inertia}from'./generators/inertia.mjs';import{keyframes}from'./generators/keyframes.mjs';import{calcGeneratorDuration}from'./generators/utils/calc-duration.mjs';import{getFinalKeyframe}from'./keyframes/get-final.mjs';import{replaceTransitionType}from'./utils/replace-transition-type.mjs';import{WithPromise}from'./utils/WithPromise.mjs';const percentToProgress=percent=>percent/100;class JSAnimation extends WithPromise{constructor(options){super();this.state=\"idle\";this.startTime=null;this.isStopped=false;/**\n         * The current time of the animation.\n         */this.currentTime=0;/**\n         * The time at which the animation was paused.\n         */this.holdTime=null;/**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */this.playbackSpeed=1;/**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */this.stop=()=>{var _this$options$onStop,_this$options;const{motionValue}=this.options;if(motionValue&&motionValue.updatedAt!==time.now()){this.tick(time.now());}this.isStopped=true;if(this.state===\"idle\")return;this.teardown();(_this$options$onStop=(_this$options=this.options).onStop)===null||_this$options$onStop===void 0?void 0:_this$options$onStop.call(_this$options);};activeAnimations.mainThread++;this.options=options;this.initAnimation();this.play();if(options.autoplay===false)this.pause();}initAnimation(){const{options}=this;replaceTransitionType(options);const{type=keyframes,repeat=0,repeatDelay=0,repeatType,velocity=0}=options;let{keyframes:keyframes$1}=options;const generatorFactory=type||keyframes;if(process.env.NODE_ENV!==\"production\"&&generatorFactory!==keyframes){invariant(keyframes$1.length<=2,`Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`,\"spring-two-frames\");}if(generatorFactory!==keyframes&&typeof keyframes$1[0]!==\"number\"){this.mixKeyframes=pipe(percentToProgress,mix(keyframes$1[0],keyframes$1[1]));keyframes$1=[0,100];}const generator=generatorFactory({...options,keyframes:keyframes$1});/**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */if(repeatType===\"mirror\"){this.mirroredGenerator=generatorFactory({...options,keyframes:[...keyframes$1].reverse(),velocity:-velocity});}/**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */if(generator.calculatedDuration===null){generator.calculatedDuration=calcGeneratorDuration(generator);}const{calculatedDuration}=generator;this.calculatedDuration=calculatedDuration;this.resolvedDuration=calculatedDuration+repeatDelay;this.totalDuration=this.resolvedDuration*(repeat+1)-repeatDelay;this.generator=generator;}updateTime(timestamp){const animationTime=Math.round(timestamp-this.startTime)*this.playbackSpeed;// Update currentTime\nif(this.holdTime!==null){this.currentTime=this.holdTime;}else{// Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n// 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n// example.\nthis.currentTime=animationTime;}}tick(timestamp){let sample=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;const{generator,totalDuration,mixKeyframes,mirroredGenerator,resolvedDuration,calculatedDuration}=this;if(this.startTime===null)return generator.next(0);const{delay=0,keyframes,repeat,repeatType,repeatDelay,type,onUpdate,finalKeyframe}=this.options;/**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */if(this.speed>0){this.startTime=Math.min(this.startTime,timestamp);}else if(this.speed<0){this.startTime=Math.min(timestamp-totalDuration/this.speed,this.startTime);}if(sample){this.currentTime=timestamp;}else{this.updateTime(timestamp);}// Rebase on delay\nconst timeWithoutDelay=this.currentTime-delay*(this.playbackSpeed>=0?1:-1);const isInDelayPhase=this.playbackSpeed>=0?timeWithoutDelay<0:timeWithoutDelay>totalDuration;this.currentTime=Math.max(timeWithoutDelay,0);// If this animation has finished, set the current time  to the total duration.\nif(this.state===\"finished\"&&this.holdTime===null){this.currentTime=totalDuration;}let elapsed=this.currentTime;let frameGenerator=generator;if(repeat){/**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */const progress=Math.min(this.currentTime,totalDuration)/resolvedDuration;/**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */let currentIteration=Math.floor(progress);/**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */let iterationProgress=progress%1.0;/**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */if(!iterationProgress&&progress>=1){iterationProgress=1;}iterationProgress===1&&currentIteration--;currentIteration=Math.min(currentIteration,repeat+1);/**\n             * Reverse progress if we're not running in \"normal\" direction\n             */const isOddIteration=Boolean(currentIteration%2);if(isOddIteration){if(repeatType===\"reverse\"){iterationProgress=1-iterationProgress;if(repeatDelay){iterationProgress-=repeatDelay/resolvedDuration;}}else if(repeatType===\"mirror\"){frameGenerator=mirroredGenerator;}}elapsed=clamp(0,1,iterationProgress)*resolvedDuration;}/**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */const state=isInDelayPhase?{done:false,value:keyframes[0]}:frameGenerator.next(elapsed);if(mixKeyframes){state.value=mixKeyframes(state.value);}let{done}=state;if(!isInDelayPhase&&calculatedDuration!==null){done=this.playbackSpeed>=0?this.currentTime>=totalDuration:this.currentTime<=0;}const isAnimationFinished=this.holdTime===null&&(this.state===\"finished\"||this.state===\"running\"&&done);// TODO: The exception for inertia could be cleaner here\nif(isAnimationFinished&&type!==inertia){state.value=getFinalKeyframe(keyframes,this.options,finalKeyframe,this.speed);}if(onUpdate){onUpdate(state.value);}if(isAnimationFinished){this.finish();}return state;}/**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */then(resolve,reject){return this.finished.then(resolve,reject);}get duration(){return millisecondsToSeconds(this.calculatedDuration);}get time(){return millisecondsToSeconds(this.currentTime);}set time(newTime){var _this$driver;newTime=secondsToMilliseconds(newTime);this.currentTime=newTime;if(this.startTime===null||this.holdTime!==null||this.playbackSpeed===0){this.holdTime=newTime;}else if(this.driver){this.startTime=this.driver.now()-newTime/this.playbackSpeed;}(_this$driver=this.driver)===null||_this$driver===void 0?void 0:_this$driver.start(false);}get speed(){return this.playbackSpeed;}set speed(newSpeed){this.updateTime(time.now());const hasChanged=this.playbackSpeed!==newSpeed;this.playbackSpeed=newSpeed;if(hasChanged){this.time=millisecondsToSeconds(this.currentTime);}}play(){var _this$options$onPlay,_this$options2;if(this.isStopped)return;const{driver=frameloopDriver,startTime}=this.options;if(!this.driver){this.driver=driver(timestamp=>this.tick(timestamp));}(_this$options$onPlay=(_this$options2=this.options).onPlay)===null||_this$options$onPlay===void 0?void 0:_this$options$onPlay.call(_this$options2);const now=this.driver.now();if(this.state===\"finished\"){this.updateFinished();this.startTime=now;}else if(this.holdTime!==null){this.startTime=now-this.holdTime;}else if(!this.startTime){this.startTime=startTime!==null&&startTime!==void 0?startTime:now;}if(this.state===\"finished\"&&this.speed<0){this.startTime+=this.calculatedDuration;}this.holdTime=null;/**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */this.state=\"running\";this.driver.start();}pause(){this.state=\"paused\";this.updateTime(time.now());this.holdTime=this.currentTime;}complete(){if(this.state!==\"running\"){this.play();}this.state=\"finished\";this.holdTime=null;}finish(){var _this$options$onCompl,_this$options3;this.notifyFinished();this.teardown();this.state=\"finished\";(_this$options$onCompl=(_this$options3=this.options).onComplete)===null||_this$options$onCompl===void 0?void 0:_this$options$onCompl.call(_this$options3);}cancel(){var _this$options$onCance,_this$options4;this.holdTime=null;this.startTime=0;this.tick(0);this.teardown();(_this$options$onCance=(_this$options4=this.options).onCancel)===null||_this$options$onCance===void 0?void 0:_this$options$onCance.call(_this$options4);}teardown(){this.state=\"idle\";this.stopDriver();this.startTime=this.holdTime=null;activeAnimations.mainThread--;}stopDriver(){if(!this.driver)return;this.driver.stop();this.driver=undefined;}sample(sampleTime){this.startTime=0;return this.tick(sampleTime,true);}attachTimeline(timeline){var _this$driver2;if(this.options.allowFlatten){this.options.type=\"keyframes\";this.options.ease=\"linear\";this.initAnimation();}(_this$driver2=this.driver)===null||_this$driver2===void 0?void 0:_this$driver2.stop();return timeline.observe(this);}}// Legacy function support\nfunction animateValue(options){return new JSAnimation(options);}export{JSAnimation,animateValue};","map":{"version":3,"names":["invariant","pipe","clamp","millisecondsToSeconds","secondsToMilliseconds","time","activeAnimations","mix","frameloopDriver","inertia","keyframes","calcGeneratorDuration","getFinalKeyframe","replaceTransitionType","WithPromise","percentToProgress","percent","JSAnimation","constructor","options","state","startTime","isStopped","currentTime","holdTime","playbackSpeed","stop","_this$options$onStop","_this$options","motionValue","updatedAt","now","tick","teardown","onStop","call","mainThread","initAnimation","play","autoplay","pause","type","repeat","repeatDelay","repeatType","velocity","keyframes$1","generatorFactory","process","env","NODE_ENV","length","mixKeyframes","generator","mirroredGenerator","reverse","calculatedDuration","resolvedDuration","totalDuration","updateTime","timestamp","animationTime","Math","round","sample","arguments","undefined","next","delay","onUpdate","finalKeyframe","speed","min","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","done","value","isAnimationFinished","finish","then","resolve","reject","finished","duration","newTime","_this$driver","driver","start","newSpeed","hasChanged","_this$options$onPlay","_this$options2","onPlay","updateFinished","complete","_this$options$onCompl","_this$options3","notifyFinished","onComplete","cancel","_this$options$onCance","_this$options4","onCancel","stopDriver","sampleTime","attachTimeline","timeline","_this$driver2","allowFlatten","ease","observe","animateValue"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/motion-dom/dist/es/animation/JSAnimation.mjs"],"sourcesContent":["import { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/frame.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\n\nconst percentToProgress = (percent) => percent / 100;\nclass JSAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.state = \"idle\";\n        this.startTime = null;\n        this.isStopped = false;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            const { motionValue } = this.options;\n            if (motionValue && motionValue.updatedAt !== time.now()) {\n                this.tick(time.now());\n            }\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            this.options.onStop?.();\n        };\n        activeAnimations.mainThread++;\n        this.options = options;\n        this.initAnimation();\n        this.play();\n        if (options.autoplay === false)\n            this.pause();\n    }\n    initAnimation() {\n        const { options } = this;\n        replaceTransitionType(options);\n        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = options;\n        let { keyframes: keyframes$1 } = options;\n        const generatorFactory = type || keyframes;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`, \"spring-two-frames\");\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        this.calculatedDuration = calculatedDuration;\n        this.resolvedDuration = calculatedDuration + repeatDelay;\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n        this.generator = generator;\n    }\n    updateTime(timestamp) {\n        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = this;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else {\n            this.updateTime(timestamp);\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.playbackSpeed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.finished.then(resolve, reject);\n    }\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration);\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n        }\n        this.driver?.start(false);\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        this.updateTime(time.now());\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        this.options.onPlay?.();\n        const now = this.driver.now();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n            this.startTime = now;\n        }\n        else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime ?? now;\n        }\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration;\n        }\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        this.state = \"paused\";\n        this.updateTime(time.now());\n        this.holdTime = this.currentTime;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.notifyFinished();\n        this.teardown();\n        this.state = \"finished\";\n        this.options.onComplete?.();\n    }\n    cancel() {\n        this.holdTime = null;\n        this.startTime = 0;\n        this.tick(0);\n        this.teardown();\n        this.options.onCancel?.();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.startTime = this.holdTime = null;\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(sampleTime) {\n        this.startTime = 0;\n        return this.tick(sampleTime, true);\n    }\n    attachTimeline(timeline) {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\";\n            this.options.ease = \"linear\";\n            this.initAnimation();\n        }\n        this.driver?.stop();\n        return timeline.observe(this);\n    }\n}\n// Legacy function support\nfunction animateValue(options) {\n    return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}