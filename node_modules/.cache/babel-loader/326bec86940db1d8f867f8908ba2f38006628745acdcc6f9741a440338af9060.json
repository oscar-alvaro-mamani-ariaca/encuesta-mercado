{"ast":null,"code":"/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */const observerCallbacks=new WeakMap();/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */const observers=new WeakMap();const fireObserverCallback=entry=>{const callback=observerCallbacks.get(entry.target);callback&&callback(entry);};const fireAllObserverCallbacks=entries=>{entries.forEach(fireObserverCallback);};function initIntersectionObserver(_ref){let{root,...options}=_ref;const lookupRoot=root||document;/**\n     * If we don't have an observer lookup map for this root, create one.\n     */if(!observers.has(lookupRoot)){observers.set(lookupRoot,{});}const rootObservers=observers.get(lookupRoot);const key=JSON.stringify(options);/**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */if(!rootObservers[key]){rootObservers[key]=new IntersectionObserver(fireAllObserverCallbacks,{root,...options});}return rootObservers[key];}function observeIntersection(element,options,callback){const rootInteresectionObserver=initIntersectionObserver(options);observerCallbacks.set(element,callback);rootInteresectionObserver.observe(element);return()=>{observerCallbacks.delete(element);rootInteresectionObserver.unobserve(element);};}export{observeIntersection};","map":{"version":3,"names":["observerCallbacks","WeakMap","observers","fireObserverCallback","entry","callback","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","_ref","root","options","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","observeIntersection","element","rootInteresectionObserver","observe","delete","unobserve"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,GACA,KAAM,CAAAA,iBAAiB,CAAG,GAAI,CAAAC,OAAO,CAAC,CAAC,CACvC;AACA;AACA;AACA;AACA,GACA,KAAM,CAAAC,SAAS,CAAG,GAAI,CAAAD,OAAO,CAAC,CAAC,CAC/B,KAAM,CAAAE,oBAAoB,CAAIC,KAAK,EAAK,CACpC,KAAM,CAAAC,QAAQ,CAAGL,iBAAiB,CAACM,GAAG,CAACF,KAAK,CAACG,MAAM,CAAC,CACpDF,QAAQ,EAAIA,QAAQ,CAACD,KAAK,CAAC,CAC/B,CAAC,CACD,KAAM,CAAAI,wBAAwB,CAAIC,OAAO,EAAK,CAC1CA,OAAO,CAACC,OAAO,CAACP,oBAAoB,CAAC,CACzC,CAAC,CACD,QAAS,CAAAQ,wBAAwBA,CAAAC,IAAA,CAAuB,IAAtB,CAAEC,IAAI,CAAE,GAAGC,OAAQ,CAAC,CAAAF,IAAA,CAClD,KAAM,CAAAG,UAAU,CAAGF,IAAI,EAAIG,QAAQ,CACnC;AACJ;AACA,OACI,GAAI,CAACd,SAAS,CAACe,GAAG,CAACF,UAAU,CAAC,CAAE,CAC5Bb,SAAS,CAACgB,GAAG,CAACH,UAAU,CAAE,CAAC,CAAC,CAAC,CACjC,CACA,KAAM,CAAAI,aAAa,CAAGjB,SAAS,CAACI,GAAG,CAACS,UAAU,CAAC,CAC/C,KAAM,CAAAK,GAAG,CAAGC,IAAI,CAACC,SAAS,CAACR,OAAO,CAAC,CACnC;AACJ;AACA;AACA,OACI,GAAI,CAACK,aAAa,CAACC,GAAG,CAAC,CAAE,CACrBD,aAAa,CAACC,GAAG,CAAC,CAAG,GAAI,CAAAG,oBAAoB,CAACf,wBAAwB,CAAE,CAAEK,IAAI,CAAE,GAAGC,OAAQ,CAAC,CAAC,CACjG,CACA,MAAO,CAAAK,aAAa,CAACC,GAAG,CAAC,CAC7B,CACA,QAAS,CAAAI,mBAAmBA,CAACC,OAAO,CAAEX,OAAO,CAAET,QAAQ,CAAE,CACrD,KAAM,CAAAqB,yBAAyB,CAAGf,wBAAwB,CAACG,OAAO,CAAC,CACnEd,iBAAiB,CAACkB,GAAG,CAACO,OAAO,CAAEpB,QAAQ,CAAC,CACxCqB,yBAAyB,CAACC,OAAO,CAACF,OAAO,CAAC,CAC1C,MAAO,IAAM,CACTzB,iBAAiB,CAAC4B,MAAM,CAACH,OAAO,CAAC,CACjCC,yBAAyB,CAACG,SAAS,CAACJ,OAAO,CAAC,CAChD,CAAC,CACL,CAEA,OAASD,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}