{"ast":null,"code":"import{resolveElements,getValueTransition,getAnimationMap,animationMapKey,getComputedStyle,fillWildcards,applyPxDefaults,NativeAnimation}from'motion-dom';import{invariant,secondsToMilliseconds}from'motion-utils';function animateElements(elementOrSelector,keyframes,options,scope){const elements=resolveElements(elementOrSelector,scope);const numElements=elements.length;invariant(Boolean(numElements),\"No valid elements provided.\",\"no-valid-elements\");/**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */const animationDefinitions=[];/**\n     * Step 1: Build options and stop existing animations (write)\n     */for(let i=0;i<numElements;i++){const element=elements[i];const elementTransition={...options};/**\n         * Resolve stagger function if provided.\n         */if(typeof elementTransition.delay===\"function\"){elementTransition.delay=elementTransition.delay(i,numElements);}for(const valueName in keyframes){let valueKeyframes=keyframes[valueName];if(!Array.isArray(valueKeyframes)){valueKeyframes=[valueKeyframes];}const valueOptions={...getValueTransition(elementTransition,valueName)};valueOptions.duration&&(valueOptions.duration=secondsToMilliseconds(valueOptions.duration));valueOptions.delay&&(valueOptions.delay=secondsToMilliseconds(valueOptions.delay));/**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */const map=getAnimationMap(element);const key=animationMapKey(valueName,valueOptions.pseudoElement||\"\");const currentAnimation=map.get(key);currentAnimation&&currentAnimation.stop();animationDefinitions.push({map,key,unresolvedKeyframes:valueKeyframes,options:{...valueOptions,element,name:valueName,allowFlatten:!elementTransition.type&&!elementTransition.ease}});}}/**\n     * Step 2: Resolve keyframes (read)\n     */for(let i=0;i<animationDefinitions.length;i++){const{unresolvedKeyframes,options:animationOptions}=animationDefinitions[i];const{element,name,pseudoElement}=animationOptions;if(!pseudoElement&&unresolvedKeyframes[0]===null){unresolvedKeyframes[0]=getComputedStyle(element,name);}fillWildcards(unresolvedKeyframes);applyPxDefaults(unresolvedKeyframes,name);/**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */if(!pseudoElement&&unresolvedKeyframes.length<2){unresolvedKeyframes.unshift(getComputedStyle(element,name));}animationOptions.keyframes=unresolvedKeyframes;}/**\n     * Step 3: Create new animations (write)\n     */const animations=[];for(let i=0;i<animationDefinitions.length;i++){const{map,key,options:animationOptions}=animationDefinitions[i];const animation=new NativeAnimation(animationOptions);map.set(key,animation);animation.finished.finally(()=>map.delete(key));animations.push(animation);}return animations;}export{animateElements};","map":{"version":3,"names":["resolveElements","getValueTransition","getAnimationMap","animationMapKey","getComputedStyle","fillWildcards","applyPxDefaults","NativeAnimation","invariant","secondsToMilliseconds","animateElements","elementOrSelector","keyframes","options","scope","elements","numElements","length","Boolean","animationDefinitions","i","element","elementTransition","delay","valueName","valueKeyframes","Array","isArray","valueOptions","duration","map","key","pseudoElement","currentAnimation","get","stop","push","unresolvedKeyframes","name","allowFlatten","type","ease","animationOptions","unshift","animations","animation","set","finished","finally","delete"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/animation/animators/waapi/animate-elements.mjs"],"sourcesContent":["import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions = [];\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        const elementTransition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements);\n        }\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName];\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes];\n            }\n            const valueOptions = {\n                ...getValueTransition(elementTransition, valueName),\n            };\n            valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n            valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element);\n            const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n            const currentAnimation = map.get(key);\n            currentAnimation && currentAnimation.stop();\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten: !elementTransition.type && !elementTransition.ease,\n                },\n            });\n        }\n    }\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];\n        const { element, name, pseudoElement } = animationOptions;\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name);\n        }\n        fillWildcards(unresolvedKeyframes);\n        applyPxDefaults(unresolvedKeyframes, name);\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name));\n        }\n        animationOptions.keyframes = unresolvedKeyframes;\n    }\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations = [];\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i];\n        const animation = new NativeAnimation(animationOptions);\n        map.set(key, animation);\n        animation.finished.finally(() => map.delete(key));\n        animations.push(animation);\n    }\n    return animations;\n}\n\nexport { animateElements };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}