{"ast":null,"code":"import{getValueTransition,makeAnimationInstant,frame,JSAnimation,AsyncMotionValueAnimation}from'motion-dom';import{secondsToMilliseconds,MotionGlobalConfig}from'motion-utils';import{getFinalKeyframe}from'../animators/waapi/utils/get-final-keyframe.mjs';import{getDefaultTransition}from'../utils/default-transitions.mjs';import{isTransitionDefined}from'../utils/is-transition-defined.mjs';const animateMotionValue=function(name,value,target){let transition=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let element=arguments.length>4?arguments[4]:undefined;let isHandoff=arguments.length>5?arguments[5]:undefined;return onComplete=>{const valueTransition=getValueTransition(transition,name)||{};/**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */const delay=valueTransition.delay||transition.delay||0;/**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */let{elapsed=0}=transition;elapsed=elapsed-secondsToMilliseconds(delay);const options={keyframes:Array.isArray(target)?target:[null,target],ease:\"easeOut\",velocity:value.getVelocity(),...valueTransition,delay:-elapsed,onUpdate:v=>{value.set(v);valueTransition.onUpdate&&valueTransition.onUpdate(v);},onComplete:()=>{onComplete();valueTransition.onComplete&&valueTransition.onComplete();},name,motionValue:value,element:isHandoff?undefined:element};/**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */if(!isTransitionDefined(valueTransition)){Object.assign(options,getDefaultTransition(name,options));}/**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */options.duration&&(options.duration=secondsToMilliseconds(options.duration));options.repeatDelay&&(options.repeatDelay=secondsToMilliseconds(options.repeatDelay));/**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */if(options.from!==undefined){options.keyframes[0]=options.from;}let shouldSkip=false;if(options.type===false||options.duration===0&&!options.repeatDelay){makeAnimationInstant(options);if(options.delay===0){shouldSkip=true;}}if(MotionGlobalConfig.instantAnimations||MotionGlobalConfig.skipAnimations){shouldSkip=true;makeAnimationInstant(options);options.delay=0;}/**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */options.allowFlatten=!valueTransition.type&&!valueTransition.ease;/**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */if(shouldSkip&&!isHandoff&&value.get()!==undefined){const finalKeyframe=getFinalKeyframe(options.keyframes,valueTransition);if(finalKeyframe!==undefined){frame.update(()=>{options.onUpdate(finalKeyframe);options.onComplete();});return;}}return valueTransition.isSync?new JSAnimation(options):new AsyncMotionValueAnimation(options);};};export{animateMotionValue};","map":{"version":3,"names":["getValueTransition","makeAnimationInstant","frame","JSAnimation","AsyncMotionValueAnimation","secondsToMilliseconds","MotionGlobalConfig","getFinalKeyframe","getDefaultTransition","isTransitionDefined","animateMotionValue","name","value","target","transition","arguments","length","undefined","element","isHandoff","onComplete","valueTransition","delay","elapsed","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","Object","assign","duration","repeatDelay","from","shouldSkip","type","instantAnimations","skipAnimations","allowFlatten","get","finalKeyframe","update","isSync"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { getValueTransition, makeAnimationInstant, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        makeAnimationInstant(options);\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (MotionGlobalConfig.instantAnimations ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        makeAnimationInstant(options);\n        options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            return;\n        }\n    }\n    return valueTransition.isSync\n        ? new JSAnimation(options)\n        : new AsyncMotionValueAnimation(options);\n};\n\nexport { animateMotionValue };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}