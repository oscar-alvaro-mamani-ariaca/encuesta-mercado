{"ast":null,"code":"import{getValueTransition,frame,positionalKeys}from'motion-dom';import{setTarget}from'../../render/utils/setters.mjs';import{addValueToWillChange}from'../../value/use-will-change/add-will-change.mjs';import{getOptimisedAppearId}from'../optimized-appear/get-appear-id.mjs';import{animateMotionValue}from'./motion-value.mjs';/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */function shouldBlockAnimation(_ref,key){let{protectedKeys,needsAnimating}=_ref;const shouldBlock=protectedKeys.hasOwnProperty(key)&&needsAnimating[key]!==true;needsAnimating[key]=false;return shouldBlock;}function animateTarget(visualElement,targetAndTransition){let{delay=0,transitionOverride,type}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};let{transition=visualElement.getDefaultTransition(),transitionEnd,...target}=targetAndTransition;if(transitionOverride)transition=transitionOverride;const animations=[];const animationTypeState=type&&visualElement.animationState&&visualElement.animationState.getState()[type];for(const key in target){var _visualElement$latest;const value=visualElement.getValue(key,(_visualElement$latest=visualElement.latestValues[key])!==null&&_visualElement$latest!==void 0?_visualElement$latest:null);const valueTarget=target[key];if(valueTarget===undefined||animationTypeState&&shouldBlockAnimation(animationTypeState,key)){continue;}const valueTransition={delay,...getValueTransition(transition||{},key)};/**\n         * If the value is already at the defined target, skip the animation.\n         */const currentValue=value.get();if(currentValue!==undefined&&!value.isAnimating&&!Array.isArray(valueTarget)&&valueTarget===currentValue&&!valueTransition.velocity){continue;}/**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */let isHandoff=false;if(window.MotionHandoffAnimation){const appearId=getOptimisedAppearId(visualElement);if(appearId){const startTime=window.MotionHandoffAnimation(appearId,key,frame);if(startTime!==null){valueTransition.startTime=startTime;isHandoff=true;}}}addValueToWillChange(visualElement,key);value.start(animateMotionValue(key,value,valueTarget,visualElement.shouldReduceMotion&&positionalKeys.has(key)?{type:false}:valueTransition,visualElement,isHandoff));const animation=value.animation;if(animation){animations.push(animation);}}if(transitionEnd){Promise.all(animations).then(()=>{frame.update(()=>{transitionEnd&&setTarget(visualElement,transitionEnd);});});}return animations;}export{animateTarget};","map":{"version":3,"names":["getValueTransition","frame","positionalKeys","setTarget","addValueToWillChange","getOptimisedAppearId","animateMotionValue","shouldBlockAnimation","_ref","key","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty","animateTarget","visualElement","targetAndTransition","delay","transitionOverride","type","arguments","length","undefined","transition","getDefaultTransition","transitionEnd","target","animations","animationTypeState","animationState","getState","_visualElement$latest","value","getValue","latestValues","valueTarget","valueTransition","currentValue","get","isAnimating","Array","isArray","velocity","isHandoff","window","MotionHandoffAnimation","appearId","startTime","start","shouldReduceMotion","has","animation","push","Promise","all","then","update"],"sources":["C:/Users/oscar/Downloads/project (5)/src/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs"],"sourcesContent":["import { getValueTransition, frame, positionalKeys } from 'motion-dom';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\nimport { animateMotionValue } from './motion-value.mjs';\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        };\n        /**\n         * If the value is already at the defined target, skip the animation.\n         */\n        const currentValue = value.get();\n        if (currentValue !== undefined &&\n            !value.isAnimating &&\n            !Array.isArray(valueTarget) &&\n            valueTarget === currentValue &&\n            !valueTransition.velocity) {\n            continue;\n        }\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nexport { animateTarget };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}